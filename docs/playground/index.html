<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Helix Playground — Edit DAG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Cytoscape -->
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
  <style>
    :root {
      --bg: #0b0e14; --fg: #e6e1cf; --muted: #9da5b4; --accent: #7aa2f7; --ok: #8bd5ca; --warn:#f5a97f; --danger:#ed8796;
    }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
    header { padding: 12px 16px; border-bottom: 1px solid #1f2430; display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    header h1 { font-size: 16px; margin: 0 12px 0 0; color: var(--accent); }
    header .controls { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .panel { display:grid; grid-template-columns: 1fr 320px; height: calc(100vh - 58px); }
    #cy { background:#0f131a; }
    aside { border-left: 1px solid #1f2430; padding: 12px; overflow:auto; }
    aside h2 { font-size:14px; margin: 6px 0 8px; color:#a6accd; }
    input[type="file"], button, select { background:#171a22; color:var(--fg); border:1px solid #2a2f3a; border-radius:6px; padding:6px 10px; cursor:pointer; }
    input[type="range"] { width: 160px; }
    .kv { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; white-space: pre-wrap; word-break: break-word; }
    .diff { background:#0f131a; padding:8px; border:1px solid #222838; border-radius:8px; }
    mark { background: #2d3f6c; color:#dbe4ff; padding:0 2px; border-radius:3px; }
    small.hint{ color:#8087a2; }
  </style>
</head>
<body>
  <header>
    <h1>Helix Edit DAG Playground</h1>
    <div class="controls">
      <input id="file" type="file" accept=".json" />
      <button id="loadSample">Load sample</button>
      <label>Min prob <input id="pmin" type="range" min="0" max="1" step="0.001" value="0"></label>
      <label>Max time <input id="tmax" type="range" min="0" max="16" step="1" value="16"></label>
      <select id="layout">
        <option value="cose">Layout: COSE</option>
        <option value="breadthfirst">Layout: Breadthfirst</option>
        <option value="concentric">Layout: Concentric</option>
      </select>
      <button id="exportPng">Export PNG</button>
    </div>
  </header>
  <div class="panel">
    <div id="cy"></div>
    <aside>
      <h2>Node</h2>
      <div id="nodeMeta" class="kv">Select a node…</div>
      <h2>Sequence Diff <small class="hint">(root → node)</small></h2>
      <div id="diff" class="diff mono">—</div>
    </aside>
  </div>

  <script>
    // ---------- helpers ----------
    function exp(x){ return Math.exp(x); }
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function colorRamp01(x){
      // 0..1 → nice blue→purple→pink ramp
      const t = clamp(x, 0, 1);
      const r = Math.round(255 * t);
      const g = Math.round(120 * (1 - t));
      const b = Math.round(200 + 55 * (1 - t));
      return `rgb(${r},${g},${b})`;
    }
    function firstDiffIndex(a,b){
      const n = Math.min(a.length, b.length);
      for (let i=0;i<n;i++){ if (a[i]!==b[i]) return i; }
      if (a.length!==b.length) return n;
      return -1;
    }
    function simpleDiffHTML(a,b){
      if (!a || !b) return "—";
      const i = firstDiffIndex(a,b);
      if (i < 0) return "<small>No difference</small>";
      // Find last differing index by walking from end
      let jA = a.length-1, jB = b.length-1;
      while (jA>=i && jB>=i && a[jA]===b[jB]){ jA--; jB--; }
      const before = a.slice(Math.max(0,i-30), i);
      const aMid = a.slice(i, jA+1);
      const after = a.slice(jA+1, Math.min(a.length, jA+1+30));
      const bMid = b.slice(i, jB+1);
      return [
        '<div><small class="hint">before</small></div>',
        '<div class="mono">…', before.replace(/</g,'&lt;'), '</div>',
        '<div><small class="hint">root change</small></div>',
        '<div class="mono"><mark>', aMid.replace(/</g,'&lt;'), '</mark></div>',
        '<div><small class="hint">node change</small></div>',
        '<div class="mono"><mark>', bMid.replace(/</g,'&lt;'), '</mark></div>',
        '<div><small class="hint">after</small></div>',
        '<div class="mono">', after.replace(/</g,'&lt;'), '…</div>'
      ].join('');
    }
    function nodesAndEdgesFromArtifact(payload){
      const nodes = [], edges = [];
      const ns = payload.nodes || {};
      // compute prob min/max
      let ps = Object.values(ns).map(n => exp(n.log_prob || 0));
      let pmin = Math.min(...ps), pmax = Math.max(...ps);
      const span = Math.max(1e-12, pmax - pmin);
      for (const [id, n] of Object.entries(ns)){
        const p = exp(n.log_prob || 0);
        const stage = (n.metadata && n.metadata.stage) || 'unknown';
        const t = (n.metadata && n.metadata.time_step) ?? null;
        const prob01 = (p - pmin) / span;
        nodes.push({
          data: {
            id, label: id + "\n" + stage + (t!==null? "\nt="+t : ""),
            prob: p, prob01,
            stage: stage, t: t,
            sequences: n.sequences || null
          }
        });
      }
      for (const e of (payload.edges || [])){
        edges.push({
          data: {
            id: e.source + "→" + e.target + ":" + (e.rule || ''),
            source: e.source, target: e.target, rule: e.rule || ''
          }
        });
      }
      return {nodes, edges};
    }

    // ---------- cytoscape setup ----------
    const cy = cytoscape({
      container: document.getElementById('cy'),
      elements: [],
      style: [
        {
          selector: 'node',
          style: {
            'shape': 'round-rectangle',
            'background-color': ele => colorRamp01(ele.data('prob01') || 0.5),
            'border-width': 1, 'border-color': '#2a2f3a',
            'width': ele => 40 + 60 * (ele.data('prob01') || 0.5),
            'height': 28,
            'label': 'data(label)',
            'font-size': 9, 'color': '#e6e1cf', 'text-wrap': 'wrap', 'text-max-width': 120
          }
        },
        {
          selector: 'edge',
          style: {
            'curve-style': 'bezier', 'target-arrow-shape': 'triangle',
            'line-color': '#3b4252', 'target-arrow-color': '#3b4252',
            'width': 1.5, 'label': 'data(rule)', 'font-size': 8, 'color': '#9da5b4',
            'text-rotation': 'autorotate', 'text-margin-y': -6
          }
        },
        { selector: ':selected', style: { 'border-color': '#7aa2f7', 'border-width': 2 } }
      ],
      wheelSensitivity: 0.2,
    });

    function runLayout(name){
      cy.layout({ name, animate: true, fit: true, padding: 20, spacingFactor: 1.2 }).run();
    }

    // ---------- UI plumbing ----------
    const fileInput = document.getElementById('file');
    const loadSampleBtn = document.getElementById('loadSample');
    const pminSlider = document.getElementById('pmin');
    const tmaxSlider = document.getElementById('tmax');
    const layoutSel = document.getElementById('layout');
    const nodeMeta = document.getElementById('nodeMeta');
    const diffBox = document.getElementById('diff');

    let payload = null; let rootSeqs = null;

    function renderPayload(){
      const {nodes, edges} = nodesAndEdgesFromArtifact(payload);
      cy.elements().remove();
      cy.add(nodes).add(edges);
      // sliders: set ranges based on data
      const maxT = Math.max( ...nodes.map(n => n.data.t ?? 0), 0 );
      tmaxSlider.max = String(Math.max(1, maxT));
      filterAndLayout();
    }

    function filterAndLayout(){
      const pmin = parseFloat(pminSlider.value || '0');
      const tmax = parseInt(tmaxSlider.value || '999', 10);
      cy.nodes().forEach(n => {
        const show = (n.data('prob') >= pmin) && ((n.data('t') ?? 0) <= tmax);
        n.style('display', show ? 'element' : 'none');
      });
      cy.edges().forEach(e => {
        const s = e.source(), t = e.target();
        e.style('display', (s.style('display') !== 'none' && t.style('display') !== 'none') ? 'element' : 'none');
      });
      runLayout(layoutSel.value);
    }

    cy.on('tap', 'node', evt => {
      const n = evt.target;
      const meta = {
        id: n.id(), prob: n.data('prob').toFixed(6),
        stage: n.data('stage'), time_step: n.data('t')
      };
      nodeMeta.textContent = JSON.stringify(meta, null, 2);
      // sequences
      const seqs = n.data('sequences') || {};
      const root = payload.nodes[payload.root_id]?.sequences || {};
      // try to find a shared chrom; fallback to first
      const chroms = Object.keys(seqs);
      const rootChroms = Object.keys(root);
      const chrom = chroms.find(c => rootChroms.includes(c)) || chroms[0];
      if (chrom){
        diffBox.innerHTML = simpleDiffHTML(root[chrom], seqs[chrom]);
      } else {
        diffBox.textContent = "—";
      }
    });

    fileInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const reader = new FileReader();
      reader.onload = ev => {
        try {
          payload = JSON.parse(ev.target.result);
          renderPayload();
        } catch (err){
          alert("Failed to parse JSON: " + err);
        }
      };
      reader.readAsText(f);
    });

    layoutSel.addEventListener('change', filterAndLayout);
    pminSlider.addEventListener('input', filterAndLayout);
    tmaxSlider.addEventListener('input', filterAndLayout);

    document.getElementById('exportPng').addEventListener('click', () => {
      const png = cy.png({ output: 'blob', full: true, scale: 2 });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(png); a.download = 'helix_edit_dag.png'; a.click();
      URL.revokeObjectURL(a.href);
    });

    loadSampleBtn.addEventListener('click', () => {
      // Tiny inline sample; replace with your full demo JSON if you like.
      payload = {
        artifact:"helix.crispr.edit_dag.v1", version:"1",
        root_id:"node_0",
        nodes:{
          node_0:{log_prob:0.0, metadata:{stage:"root", time_step:0},
                  sequences:{chrDemo:"AAAACGTACGTAAAA"}},
          node_1:{log_prob:-0.5, metadata:{stage:"cut", time_step:1},
                  sequences:{chrDemo:"AAAACGTACGTAAAA"}},
          node_2:{log_prob:-0.7, metadata:{stage:"repaired", time_step:2},
                  sequences:{chrDemo:"AAAATGCACGTAAAA"}},
          node_3:{log_prob:-1.2, metadata:{stage:"repaired", time_step:2},
                  sequences:{chrDemo:"AAAAACGTACGAAAA"}}
        },
        edges:[
          {source:"node_0", target:"node_1", rule:"crispr.clean_cut",
           event:{chrom:"chrDemo", start:4, end:4, replacement:""}},
          {source:"node_1", target:"node_2", rule:"crispr.indel_branch",
           event:{chrom:"chrDemo", start:4, end:8, replacement:"TGCA"}},
          {source:"node_1", target:"node_3", rule:"crispr.indel_branch",
           event:{chrom:"chrDemo", start:8, end:9, replacement:""}}
        ]
      };
      renderPayload();
    });

    // Optional: auto-load ?json= URL param
    const params = new URLSearchParams(location.search);
    if (params.get('json')){
      fetch(params.get('json')).then(r => r.json()).then(j => { payload=j; renderPayload(); });
    }
  </script>
</body>
</html>
