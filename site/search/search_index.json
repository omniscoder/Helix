{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Veri\u2011Helix","text":"<p>Helix is a research\u2011grade bioinformatics toolbox that \u201cproves what it plots.\u201d Every figure and workflow carries schema validation, versioned specs, and cryptographic provenance so you can trust what you share and reproduce what you see.</p> <ul> <li>Install: <code>pip install \"veri-helix[viz,schema,protein]\"</code></li> <li>First look: <code>helix demo viz --all</code></li> <li>Why it matters \u2192 Artifacts &amp; Provenance</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Run a triage snapshot (GC skew + k\u2011mer hotspots + ORFs) and save a ready\u2011to\u2011share plot:</p> <pre><code>helix triage --input path/to/sequence.fna --k 5 --min-orf-length 90 --json triage.json\nhelix viz triage --json triage.json --output triage.png\n</code></pre> <p>Fold RNA and export dot\u2011bracket and ensemble plots:</p> <pre><code>helix rna mfe --fasta path/to/seq.fna --dotbracket mfe.dbn\nhelix rna ensemble --fasta path/to/seq.fna --gamma 1.0 \\\n  --dotplot dotplot.png --arc arc.png --entropy-plot entropy.png\n</code></pre> <p>Notebook\u2011friendly API (plain dict/list payloads):</p> <pre><code>from helix import api as hx\nreport = hx.triage_report(sequence=\"AUGGCCUUUUAA\", k=3)\nfold   = hx.fold_rna(\"GGGAAACCC\", min_loop_length=0)\n</code></pre>"},{"location":"#deep-wiki-project-map","title":"Deep Wiki (Project Map)","text":"<p>Use this \u201cdeep wiki\u201d map to jump directly to the concept or tool you need:</p> <ul> <li>Getting Started: installation, CLI entry points, extras \u2192 Getting Started</li> <li>Concepts: how Helix treats data and evidence</li> <li>Artifacts &amp; provenance (hashes, versioned specs) \u2192 Artifacts &amp; Provenance</li> <li>Schemas (contracts for JSON/viz payloads) \u2192 Schemas</li> <li>Workflows (YAML pipelines + schema hooks) \u2192 Workflows</li> <li>CLI Guides</li> <li>Visualization commands \u2192 CLI: Visualization</li> <li>Schema tools (show/spec/manifest/diff) \u2192 CLI: Schema Tools</li> <li>Workflows runner and config \u2192 CLI: Workflows</li> <li>Demos and fixtures \u2192 CLI: Demos</li> <li>API Reference (notebook\u2011first helpers) \u2192 helix.api</li> <li>Visualization Gallery (spec\u2011stamped figures)</li> <li>Alignment Ribbon \u2192 Alignment Ribbon</li> <li>RNA Dot\u2011Plot \u2192 RNA Dot\u2011Plot</li> <li>Motif Logo \u2192 Motif Logo</li> <li>Distance Heatmap \u2192 Distance Heatmap</li> <li>Minimizer Density \u2192 Minimizer Density</li> <li>Schema Reference (all kinds, versions, and samples) \u2192 Schema Reference</li> <li>Performance Dashboard (CI trends for time + memory) \u2192 Benchmarks</li> <li>What\u2019s New (highlights across releases) \u2192 What\u2019s New</li> <li>Contributing (style, tests, ideas) \u2192 Contributing</li> </ul>"},{"location":"#benchmarks-reproducibility","title":"Benchmarks &amp; Reproducibility","text":"<p>Helix includes a research\u2011grade benchmark harness. Every run emits a schema\u2011tagged JSON that captures git SHA, BLAS vendor, CPU/threads, RNG seed, per\u2011case timing, and RSS peaks. CI appends results to <code>docs/data/bench/history.csv</code>; the live dashboard renders trends without servers or external deps.</p> <ul> <li>See live trends \u2192 Benchmarks</li> <li>Harness CLI \u2192 <code>python -m benchmarks.api_benchmarks --help</code></li> </ul>"},{"location":"#design-principles","title":"Design Principles","text":"<ul> <li>Evidence\u2011first: every artifact ships with a contract (schema) and provenance (hashes, spec version, parameters).</li> <li>Friendly internals: approachable implementations of classic algorithms, with JSON payloads you can inspect and remix.</li> <li>CLI \u21c4 API symmetry: what you can do from the shell, you can reproduce in a notebook\u2014and vice versa.</li> <li>Research\u2011grade: optional heavy datasets, performance dashboards, and drift gates in CI for trustworthy iterations.</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Helix ships a JSON benchmark harness (<code>python -m benchmarks.api_benchmarks</code>) and continuously publishes the results to CI. The goals are:</p> <ul> <li>Comparable runs: every payload is tagged with commit SHA, dataset provenance, CPU/threads, BLAS vendor, RNG seed, and per-case RSS stats.</li> <li>Drift detection: CI rejects PRs when a case slows down by more than 5\u202f% relative to <code>.bench/baseline.json</code>.</li> <li>Transparency: the latest measurements are summarized here, powered by the CSV in <code>docs/data/bench/history.csv</code> (populated automatically on <code>main</code>).</li> </ul>"},{"location":"benchmarks/#running-locally","title":"Running locally","text":"<pre><code>python -m benchmarks.api_benchmarks \\\n  --repeat 5 \\\n  --warmup 1 \\\n  --limit 0 \\\n  --out bench-results/api.json \\\n  --summary-md bench-results/api.md\n</code></pre> <ul> <li><code>--limit N</code> keeps only the first <code>N</code> nucleotides/aminos (0 = entire dataset). Use this for quick inner-loop runs or to mimic CI\u2019s 10k-sample sweep.</li> <li>Override datasets with <code>HELIX_BENCH_DNA_FASTA=/abs/path/...</code> and <code>HELIX_BENCH_PROTEIN_FASTA=/abs/path/...</code>. The harness records those paths in the JSON payload so dashboards can compare apples-to-apples.</li> <li>Pass <code>--baseline path/to/baseline.json</code> to compute \u0394% vs. a stored run. <code>scripts/bench_check.py baseline current --threshold 5</code> is what CI uses to gate regressions.</li> </ul>"},{"location":"benchmarks/#heavy-datasets-via-github-actions","title":"Heavy datasets via GitHub Actions","text":"<p>Trigger a manual heavy sweep from the Actions \u2192 CI \u2192 Run workflow button:</p> <ol> <li>Set <code>bench_heavy</code> to <code>true</code> (this bumps repeats to 10 and disables the 10k sampling limit).</li> <li>Optionally provide runner-accessible overrides for <code>dna_fasta</code> / <code>protein_fasta</code>. On hosted runners you typically leave these blank; on self-hosted boxes you can point at a mounted volume or fetcher script.</li> </ol> <p>Each run publishes:</p> <ul> <li><code>benchmarks/out/bench-&lt;SHA&gt;.json</code> \u2014  the full schema payload.</li> <li><code>benchmarks/out/bench-&lt;SHA&gt;.md</code> \u2014 a Markdown table appended to the CI summary.</li> <li><code>docs/data/bench/history.csv</code> (main branch only) \u2014 an append-only log that powers the chart below.</li> </ul>"},{"location":"benchmarks/#trend-mean-seconds","title":"Trend (mean seconds)","text":"<p>The gallery below visualizes every <code>*.mean_s</code> column recorded in <code>docs/data/bench/history.csv</code> and summarizes the latest run.</p> <p>CSV source: <code>docs/data/bench/history.csv</code>. Commit history contains the raw JSON artifacts under <code>benchmarks/out/</code> (uploaded by CI) if you need to recompute metrics offline.</p>"},{"location":"cli/","title":"CLI Cheat Sheet","text":"<p>All commands are subcommands of the <code>helix</code> console entry point. The most common flags mirror the Python API arguments.</p> Command What it does <code>helix dna --input path.fna</code> GC stats + k-mer clusters <code>helix triage --input path.fna --json triage.json</code> Combined GC/k-mer/ORF report (JSON + optional plots) <code>helix spectrum --peptide NQEL --spectrum \"\u2026\"</code> Theoretical spectra + leaderboard scoring <code>helix rna mfe --fasta seq.fna --dotbracket out.dbn</code> Zuker-style MFE folding <code>helix rna ensemble --fasta seq.fna --gamma 1.0</code> Partition function + MEA/centroid + dot-plot/entropy <code>helix protein --input protein.faa</code> Protein summaries/hydropathy (requires Biopython) <code>helix viz triage --json triage.json --output triage.png</code> Plot triage payloads (requires matplotlib) <code>helix viz hydropathy --input src/helix/datasets/protein/demo_protein.faa --window 11</code> Plot hydropathy profile (Biopython + matplotlib) <code>helix string search --pattern GATTACA --k 1 seqs.fna</code> FM-index exact search (<code>k=0</code>) or \u2264k Myers hits with JSON output <code>helix seed index --method minimizer --k 15 --window 10 seq.fna</code> Emit minimizers/syncmers + optional density plots <code>helix seed map --ref ref.fna --reads reads.fna --k 15 --window 10</code> Toy seed-and-extend mapping summary <code>helix dbg build --reads reads.fna --k 31 --graph dbg.json</code> Build a DBG + optional GraphML <code>helix dbg clean --graph dbg.json --out dbg_clean.json</code> Remove tips/bubbles via CLI <code>helix dbg color --reads sample1.fna sample2.fna --k 31</code> Produce colored DBG presence JSON <code>helix motif find --fasta seqs.fna --width 8 --solver steme</code> PWM discovery via EM/STEME/online + optional JSON/plot <code>helix sketch build --method minhash --fasta seq.fna --k 21 --size 1000</code> Build a MinHash or HLL sketch <code>helix sketch compare --method hll --fasta-a a.fna --fasta-b b.fna</code> HLL Jaccard/cardinality or Mash distance <code>helix workflows --config workflows/plasmid_screen.yaml</code> Run YAML-defined pipelines <p>Tip: add <code>PYTHONPATH=src</code> when running from the repo root or install with <code>pip install -e .</code>.</p>"},{"location":"contributing/","title":"Contributing","text":"<ol> <li>Fork \u2192 <code>pip install -e \".[dev]\"</code>.</li> <li>Run <code>pytest -q</code> plus <code>mkdocs serve</code> to preview docs.</li> <li>Open a PR with:</li> <li>Tests for new features (especially schema/viz contracts).</li> <li>Docs updates (README + MkDocs page).</li> <li><code>CHANGELOG.md</code> entry.</li> </ol> <p>Schema or viz changes should include manifest diffs and sample artifacts (<code>helix demo viz</code>) so reviewers can verify provenance.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<pre><code>pip install veri-helix[viz,schema,protein]\nhelix demo viz --all\n</code></pre> <p>This generates images and <code>.viz.json</code> sidecars (with <code>spec_version</code>, <code>input_sha256</code>, timestamps, and tool version). If you can see it, you can verify it.</p>"},{"location":"schema-reference/","title":"Schema Reference","text":"<p>Use <code>helix schema manifest --out schemas.json</code> to export the latest registry. Each entry includes:</p> <ul> <li><code>schema_kind</code> (e.g., <code>viz_alignment_ribbon</code>)</li> <li><code>spec_version</code></li> <li>JSON Schema (properties + types)</li> </ul> <p>Keep this file under version control for publications or pipelines. Combine with <code>helix schema diff</code> to review changes between releases.</p>"},{"location":"schema/","title":"Schema Reference","text":"<p>Helix ships a schema registry so every JSON artifact (CLI output, workflow step, visualization payload) can be validated and traced back to the exact <code>spec_version</code>.</p> <ul> <li>Current spec version: see <code>src/helix/schema/spec_manifest.json</code> (loaded automatically by the CLI and docs). Version <code>1.0</code> covers the visualization payloads listed below.</li> <li>Inspect schemas from the CLI: <code>helix viz schema</code> (lists keys) or <code>helix viz schema --kind viz_alignment_ribbon</code> (prints the JSON schema for one payload).</li> <li>Export a manifest: <code>helix schema manifest --out schemas.json</code> writes the spec manifest (including every schema, validator availability, and the current <code>spec_version</code>). Ideal for publications or workflow lockfiles.</li> <li>Diff manifests: <code>helix schema diff --base old_manifest.json [--target new_manifest.json]</code> summarizes added/removed/modified schemas (use <code>--format json</code> for machine-friendly reports).</li> </ul>"},{"location":"schema/#registered-schemas","title":"Registered Schemas","text":"<p>All schemas live under the <code>viz_*</code> namespace today and correspond to the visualization contracts in Visualization JSON Schemas. Use <code>helix schema manifest</code> to obtain the machine-readable form; a truncated excerpt:</p> <pre><code>$ helix schema manifest | jq '.schemas.viz_alignment_ribbon.schema.properties | keys'\n[\n  \"cigar\",\n  \"metadata\",\n  \"qry_length\",\n  \"qry_start\",\n  \"ref_length\",\n  \"ref_start\"\n]\n</code></pre> <p>Whenever we add optional fields, the spec version bumps to <code>1.x</code>. Breaking changes (field removal/renames) would trigger a major bump to <code>2.0</code>. The manifest + CLI help make these bumps explicit.</p>"},{"location":"schema/#workflow-provenance","title":"Workflow Provenance","text":"<p>Workflows can declare schema expectations per step:</p> <pre><code>steps:\n  - command: [\"seed\", \"map\"]\n    args: {...}\n    schema:\n      kind: viz_alignment_ribbon\n      output: map.json\n</code></pre> <p>When you run <code>helix workflows ... --with-schema</code>, Helix validates the artifact, stamps <code>spec_version</code> + <code>input_sha256</code>, and prints a provenance table summarizing <code>{step, schema kind, version, SHA256, status}</code>\u2014handy for reviewers and archival logs.</p> <p>Pair <code>helix schema manifest</code> with <code>helix workflow</code> outputs to guarantee every JSON artifact in your pipeline references a declared schema.</p>"},{"location":"viz/","title":"Visualization JSON Schemas","text":"<p>Current viz-spec version: 1.0 (backwards compatibility is maintained for at least the next two Helix releases). Every viz-spec JSON embeds this version alongside a timestamp and an <code>input_sha256</code> so the figure footer cryptographically references the exact JSON that produced it.</p> <ul> <li>Inspect schemas directly from the CLI: <code>helix viz schema</code> (lists keys) or <code>helix viz schema --kind viz_motif_logo</code> (pretty JSON schema).</li> <li>Generate ready-to-plot payloads + screenshots via <code>helix demo viz --output demo_viz/</code>\u2014the gallery at the end of this page was produced with that command.</li> </ul> <p>Every renderer under <code>helix viz ...</code> consumes a small JSON contract. The schemas below are append-only; version bumps surface via the <code>spec_version</code> embedded in each viz-spec JSON as well as the figure footer.</p>"},{"location":"viz/#minimizer-density-helix-viz-minimizers","title":"Minimizer Density (<code>helix viz minimizers</code>)","text":"<pre><code>{\n  \"sequence_length\": 12345,\n  \"minimizers\": [42, [100, \"ACG\", 1234567], {\"pos\": 777}]\n}\n</code></pre> <ul> <li><code>sequence_length</code> (int) \u2013 total sequence length.</li> <li><code>minimizers</code> (array) \u2013 accepts raw positions (<code>int</code>), tuples like <code>[pos, kmer]</code> or <code>[pos, kmer, hash]</code>, and dicts containing <code>pos</code>, <code>position</code>, or <code>ref_start</code>.</li> </ul>"},{"location":"viz/#seed-chain-helix-viz-seed-chain","title":"Seed Chain (<code>helix viz seed-chain</code>)","text":"<pre><code>{\n  \"ref_length\": 1200,\n  \"qry_length\": 1100,\n  \"chains\": [\n    [{\"ref_start\":100,\"ref_end\":160,\"qry_start\":90,\"qry_end\":150}],\n    [{\"ref_start\":400,\"ref_end\":450,\"qry_start\":390,\"qry_end\":440}]\n  ]\n}\n</code></pre> <ul> <li><code>ref_length</code> / <code>qry_length</code> (ints) \u2013 axis bounds for the reference and query.</li> <li><code>chains</code> (list[list[anchor]]) \u2013 each anchor needs <code>ref_start</code>/<code>qry_start</code> plus either <code>ref_end</code>/<code>qry_end</code> or <code>len</code>.</li> </ul>"},{"location":"viz/#rna-dot-plot-helix-viz-rna-dotplot","title":"RNA Dot-Plot (<code>helix viz rna-dotplot</code>)","text":"<pre><code>{ \"posterior\": [[0,0.7,0],[0.7,0,0.4],[0,0.4,0]] }\n</code></pre> <ul> <li><code>posterior</code> (n\u00d7n floats in <code>[0,1]</code>) \u2013 the upper triangle is plotted; the lower triangle is ignored.</li> </ul>"},{"location":"viz/#alignment-ribbon-helix-viz-alignment-ribbon","title":"Alignment Ribbon (<code>helix viz alignment-ribbon</code>)","text":"<pre><code>{\n  \"ref_length\": 500,\n  \"qry_length\": 480,\n  \"cigar\": \"50M2I20M3D30M\",\n  \"ref_start\": 100,\n  \"qry_start\": 95,\n  \"metadata\": {\"name\":\"read_001\",\"score\":87}\n}\n</code></pre> <ul> <li><code>ref_length</code>, <code>qry_length</code> (ints) \u2013 axis bounds; fall back to <code>ref_end</code>/<code>read_end</code> if omitted.</li> <li><code>cigar</code> (SAM string) \u2013 supports <code>M</code>, <code>=</code>, <code>X</code>, <code>I</code>, <code>D</code>.</li> <li><code>ref_start</code>, <code>qry_start</code> (ints) \u2013 0-based alignment anchors.</li> <li><code>metadata</code> (object, optional) \u2013 echoed into the viz-spec and footer for provenance.</li> </ul> <p>Outputs from <code>helix seed map</code> already match this schema via the <code>meta</code>/<code>results</code> structure; <code>helix viz alignment-ribbon</code> accepts those JSON blobs directly.</p>"},{"location":"viz/#distance-heatmap-helix-viz-distance-heatmap","title":"Distance Heatmap (<code>helix viz distance-heatmap</code>)","text":"<pre><code>{\n  \"labels\": [\"A\",\"B\",\"C\"],\n  \"matrix\": [[0,0.05,0.10],[0.05,0,0.12],[0.10,0.12,0]]\n}\n</code></pre> <ul> <li><code>labels</code> (list[str]) \u2013 row/column labels.</li> <li><code>matrix</code> (n\u00d7n floats) \u2013 symmetric distance matrix (diagonal usually zero).</li> </ul> <p>To plot a matrix emitted by <code>helix sketch compare --json dist.json</code>, pass that file to <code>helix viz distance-heatmap</code>.</p>"},{"location":"viz/#motif-logo-helix-viz-motif-logo","title":"Motif Logo (<code>helix viz motif-logo</code>)","text":"<pre><code>{\n  \"alphabet\": [\"A\",\"C\",\"G\",\"T\"],\n  \"pwm\": [\n    [0.25,0.25,0.25,0.25],\n    [0.05,0.05,0.85,0.05],\n    [0.6,0.1,0.1,0.2]\n  ],\n  \"background\": [0.25,0.25,0.25,0.25]\n}\n</code></pre> <ul> <li><code>alphabet</code> (list[str]) \u2013 order for PWM columns; defaults to <code>[\"A\",\"C\",\"G\",\"T\"]</code>.</li> <li><code>pwm</code> (L\u00d7|\u03a3| floats or list of dicts) \u2013 probabilities per symbol; each column is normalized if needed.</li> <li><code>background</code> (|\u03a3| floats, optional) \u2013 background distribution for information-content scaling (defaults to uniform).</li> </ul>"},{"location":"viz/#reproducible-viz-viz-spec","title":"Reproducible Viz &amp; Viz-Spec","text":"<ul> <li>All viz commands support <code>--save out.png</code> (PNG/SVG/PDF) and automatically emit a matching <code>.viz.json</code> unless <code>--save-viz-spec</code> overrides the destination. The <code>meta.input_sha256</code> ties each plot to its JSON input.</li> <li>Every viz-spec includes <code>kind</code>, <code>meta</code>, <code>primitives</code>, <code>spec_version</code>, and a timestamp; the figure footer mirrors this information for easy provenance.</li> <li>Tests assert against viz-spec metrics (counts, quantiles, densities) rather than raw pixels, keeping the suite deterministic across platforms.</li> <li>Producers such as <code>helix seed map</code>, <code>helix sketch compare</code>, and <code>helix motif find</code> now stamp <code>spec_version</code> into their JSON outputs so downstream users can validate artifacts.</li> <li>Whenever you write a PNG via <code>--save</code>, Helix drops a sibling <code>&lt;image&gt;.provenance.json</code> that captures <code>{schema_kind, spec_version, input_sha256, viz_spec_sha256, image_sha256, helix_version, command}</code>, giving every figure a cryptographic audit trail.</li> </ul>"},{"location":"viz/#demo-gallery","title":"Demo Gallery","text":"<p>Run <code>helix demo viz --output docs/assets/viz</code> to recreate the screenshots below (each PNG is paired with a <code>.viz.json</code> containing the schema metadata):</p> Visualization Preview Minimizer density Seed chaining RNA dot-plot Alignment ribbon Distance heatmap Motif logo"},{"location":"whats-new/","title":"What\u2019s New","text":"<p>This page highlights notable improvements across recent releases. For the full history, see <code>CHANGELOG.md</code> in the repository root.</p>"},{"location":"whats-new/#020-schemastamped-viz-provenance-and-manifests","title":"0.2.0 \u2014 Schema\u2011Stamped Viz, Provenance, and Manifests","text":"<ul> <li>Schema manifest exports/diffs and CLI helpers for schema inspection.</li> <li>Deterministic visualization provenance: viz\u2011spec hashing, input SHA\u2011256 capture, per\u2011image <code>*.provenance.json</code> trailers.</li> <li><code>helix demo viz</code> assets + schema reference docs, <code>--schema</code> flag for every viz subcommand, and JSON workflow provenance.</li> <li>Polished optional extras (<code>viz</code>, <code>protein</code>, <code>schema</code>) and slimmer core deps.</li> </ul>"},{"location":"whats-new/#010-first-public-release","title":"0.1.0 \u2014 First Public Release","text":"<ul> <li>Initial public release of the Helix bioinformatics toolkit.</li> </ul> <p>If you\u2019re upgrading from an older version, skim the release notes above and the CLI help (<code>helix --help</code>) for any new flags or behavior.</p>"},{"location":"cli/demo/","title":"CLI: Demo","text":"<pre><code>helix demo viz --output demo_viz\n</code></pre> <p>Generates canonical JSON payloads, PNGs, <code>.viz.json</code>, and <code>.provenance.json</code> for every renderer (alignment ribbon, dot-plot, motif logo, etc.). Perfect for smoke tests or onboarding notebooks.</p>"},{"location":"cli/schema/","title":"CLI: Schema Tools","text":"<ul> <li><code>helix viz --schema</code> \u2192 display contract + sample for a specific renderer.</li> <li><code>helix schema manifest --out schemas.json</code> \u2192 export registry.</li> <li><code>helix schema diff --base old.json [--target new.json]</code> \u2192 show changes (JSON/table).</li> <li><code>helix schema manifest --format json</code> (via <code>jq</code>) helps pin schemas in papers.</li> </ul> <p>Use manifests as lockfiles for workflows or publications so data/figure contracts remain auditable.</p>"},{"location":"cli/viz/","title":"CLI: Visualization","text":"<pre><code>helix viz minimizers --input minimizers.json --save mins.png\nhelix viz minimizers --schema   # print schema + sample payload\n</code></pre> <p>Flags: - <code>--save</code> writes PNG/SVG/PDF. - <code>--save-viz-spec</code> overrides the <code>.viz.json</code> path. - <code>--schema</code> bypasses plotting and prints the JSON contract + sample payload.</p> <p>All viz commands (minimizers, seed-chain, rna-dotplot, alignment-ribbon, distance-heatmap, motif-logo) mirror this interface and emit <code>&lt;image&gt;.provenance.json</code>.</p>"},{"location":"cli/workflows/","title":"CLI: Workflows","text":"<pre><code>helix workflows --config workflows/plasmid.yaml --output-dir runs --with-schema --as-json\n</code></pre> <ul> <li><code>--with-schema</code> prints a table of <code>{step, schema_kind, spec_version, sha256}</code>.</li> <li><code>--as-json</code> emits the same data as JSON for dashboards.</li> <li>Each <code>schema: {kind, output}</code> block in the YAML validates output JSON before the next step.</li> </ul>"},{"location":"concepts/artifacts/","title":"Artifacts &amp; Provenance","text":"<p>Veri-Helix records a provenance trail for every artifact:</p> <ul> <li>Schema manifests define the JSON contract (kind + <code>spec_version</code>).</li> <li>Viz-spec JSON captures metrics about each plot plus <code>input_sha256</code>.</li> <li><code>&lt;image&gt;.provenance.json</code> pairs schema kind, viz-spec hash, and image hash.</li> </ul> <p>Together these form a chain of custody you can cite in papers or audits. For implementation details see <code>helix schema manifest</code>, <code>helix schema diff</code>, and <code>helix workflows --with-schema</code>.</p>"},{"location":"concepts/schemas/","title":"Schemas","text":"<ul> <li>Every CLI command that emits JSON stamps <code>schema_kind</code> and <code>spec_version</code>.</li> <li><code>helix schema manifest --out schemas.json</code> exports the full registry.</li> <li><code>helix schema diff --base old.json --target new.json</code> shows additions/removals.</li> <li><code>helix viz --schema</code> prints contracts plus sample payloads.</li> </ul> <p>Treat schemas like APIs: bump the version, document diffs, and add workflow validation (<code>schema: {kind, output}</code>) whenever a step produces JSON.</p>"},{"location":"concepts/workflows/","title":"Workflows","text":"<p><code>helix workflows</code> runs YAML-defined pipelines:</p> <pre><code>steps:\n  - command: dna\n    args: { sequence: ACGT..., k: 3 }\n    schema:\n      kind: viz_minimizers\n      output: dna.json\n</code></pre> <ul> <li><code>schema</code> blocks validate step outputs and stamp <code>spec_version</code> + SHA-256.</li> <li><code>helix workflows --with-schema --as-json</code> prints provenance tables suitable for dashboards.</li> <li>Logs and artifacts live under <code>--output-dir</code>, making it easy to archive runs.</li> </ul>"},{"location":"reference/api/","title":"<code>helix.api</code>","text":"<p>Research workflows often start in notebooks or lightweight scripts where shelling out to the CLI is inconvenient. The <code>helix.api</code> module mirrors the CLI surface area but returns plain Python dictionaries and lists, making it straightforward to serialize to JSON, pass through pandas, or feed into downstream visualization components.</p> <p>Simulation only: <code>helix.api</code> helpers work exclusively on digital sequences, spectra, or graphs. They never prescribe wet-lab procedures or interface with instruments\u2014use them strictly for in-silico analysis and visualization.</p> <p>The helpers prefer explicit inputs: every function accepts either an inline <code>sequence=\"ACGU...\"</code> or an <code>input_path=Path(\"sample.fasta\")</code> when DNA/protein IO is relevant. Validation happens up front\u2014invalid bases, overlapping arguments, and missing files raise informative <code>ValueError</code> or <code>ImportError</code> exceptions so that provenance remains audit-friendly.</p>"},{"location":"reference/api/#function-reference","title":"Function reference","text":""},{"location":"reference/api/#dna_summarysequencenone-input_pathnone-window200-step50-k5-max_diff1","title":"<code>dna_summary(sequence=None, *, input_path=None, window=200, step=50, k=5, max_diff=1)</code>","text":"<p>Normalize a DNA string, compute GC statistics, and discover k-mer hotspots tolerant of SNP-scale variation.</p> <p>Parameters</p> Name Type Details <code>sequence</code> <code>str \\| None</code> Inline DNA input. Cannot be combined with <code>input_path</code>. <code>input_path</code> <code>str \\| Path \\| None</code> File to read (FASTA/plain). Takes precedence over <code>sequence</code>. <code>window</code> <code>int</code> Sliding-window size for GC summaries. Set to <code>0</code> to skip. <code>step</code> <code>int</code> Advance between windows; smaller steps increase resolution. <code>k</code> <code>int</code> k-mer size used for clustering recurrent motifs. <code>max_diff</code> <code>int</code> Maximum Hamming distance when grouping similar k-mers. <p>Returns</p> <p><code>dict</code> with:</p> <ul> <li><code>sequence</code>: normalized uppercase DNA (U is converted to T, FASTA headers stripped).  </li> <li><code>length</code>: integer length of <code>sequence</code>.  </li> <li><code>gc_content</code>: float fraction (0\u20131).  </li> <li><code>gc_windows</code>: list of <code>{start, end, gc_fraction}</code> windows for downstream plotting.  </li> <li><code>kmer_clusters</code>: map keyed by canonical motif with <code>count</code>, <code>positions</code>, <code>patterns</code>.  </li> </ul> <p>The GC window calculation and k-mer clustering match the logic behind <code>helix dna summarize</code>, ensuring CLI and notebook reports stay interchangeable.</p>"},{"location":"reference/api/#triage_reportsequencenone-input_pathnone-k5-max_diff1-min_orf_length90","title":"<code>triage_report(sequence=None, *, input_path=None, k=5, max_diff=1, min_orf_length=90)</code>","text":"<p>Produce the complete \u201ctriage\u201d bundle (GC skew, motif clusters, ORF calls) that backs <code>helix viz triage</code>.</p> <p>Parameters</p> Name Type Details <code>sequence</code>, <code>input_path</code> see above Mutually exclusive DNA inputs. <code>k</code>, <code>max_diff</code> <code>int</code> Passed through to the underlying k-mer clustering. <code>min_orf_length</code> <code>int</code> Filter ORFs shorter than the threshold (nt). <p>Returns</p> <p><code>dict</code> with:</p> <ul> <li><code>sequence</code>: RNA display sequence (T\u2192U) for visualization.  </li> <li><code>skew</code>: list of cumulative skew values (len = sequence+1).  </li> <li><code>clusters</code>: each cluster has <code>canonical</code>, <code>count</code>, <code>patterns</code>, <code>positions</code>.  </li> <li><code>orfs</code>: list of ORF dicts reporting <code>start</code>, <code>end</code>, <code>strand</code>, <code>frame</code>, <code>length_nt</code>, <code>length_aa</code>, and translated <code>peptide</code>.  </li> </ul> <p>All payloads are schema-compatible with <code>helix schema show triage-report</code>.</p>"},{"location":"reference/api/#fold_rnasequence-min_loop_length3-allow_wobble_pairstrue","title":"<code>fold_rna(sequence, *, min_loop_length=3, allow_wobble_pairs=True)</code>","text":"<p>Convenience wrapper around the annotated Nussinov dynamic program for RNA folding.</p> <p>Parameters</p> Name Type Details <code>sequence</code> <code>str</code> RNA/DNA string; U/T are normalized to U internally. <code>min_loop_length</code> <code>int</code> Nussinov \u201chairpin\u201d constraint (nt separating paired bases). <code>allow_wobble_pairs</code> <code>bool</code> When <code>True</code>, GU wobble pairs are permitted in addition to AU/GC. <p>Returns</p> <p><code>dict</code> with:</p> <ul> <li><code>sequence</code>: normalized RNA string used for folding.  </li> <li><code>score</code>: optimal base-pair count reported by the DP table.  </li> <li><code>pairs</code>: list of <code>(i, j)</code> tuples describing paired indices.  </li> <li><code>dot_bracket</code>: canonical dot-bracket representation for plotting or downstream structure comparison.  </li> </ul> <p>Because the helper exposes the same knobs as <code>helix rna fold</code>, results are reproducible across interfaces.</p>"},{"location":"reference/api/#spectrum_leaderboardpeptidenone-experimental_spectrumnone-cyclictrue-leaderboard_size5","title":"<code>spectrum_leaderboard(peptide=None, *, experimental_spectrum=None, cyclic=True, leaderboard_size=5)</code>","text":"<p>Run the leaderboard cyclopeptide sequencing algorithm and return notebook-friendly results.</p> <p>Parameters</p> Name Type Details <code>peptide</code> <code>str \\| None</code> Optional candidate peptide for generating a theoretical spectrum. <code>experimental_spectrum</code> <code>Sequence[int] \\| None</code> Observed masses used for leaderboard selection. <code>cyclic</code> <code>bool</code> Whether the theoretical spectrum should be cyclic (<code>True</code>) or linear (<code>False</code>). <code>leaderboard_size</code> <code>int</code> Maximum number of peptides kept per iteration (ties are preserved). <p>Returns</p> <p><code>dict</code> with:</p> <ul> <li><code>theoretical_spectrum</code>: the computed linear/cyclic spectrum for <code>peptide</code> (empty if no peptide supplied).  </li> <li><code>leaderboard_hits</code>: list of <code>{peptide, score}</code> pairs sorted by score.  </li> </ul> <p>Pass only <code>peptide</code> to preview its spectrum, only <code>experimental_spectrum</code> to search for best-scoring sequences, or both to compare expectations vs. observed data.</p>"},{"location":"reference/api/#protein_summarysequencenone-input_pathnone-window9-step1-scalekd","title":"<code>protein_summary(sequence=None, *, input_path=None, window=9, step=1, scale=\"kd\")</code>","text":"<p>Summarize amino-acid sequences using Biopython\u2019s <code>ProtParam</code> utilities along with Helix hydropathy profiles.</p> <p>Parameters</p> Name Type Details <code>sequence</code>, <code>input_path</code> see above FASTA headers are handled transparently. <code>window</code> <code>int</code> Sliding window for hydropathy averaging. <code>step</code> <code>int</code> Offset between successive hydropathy windows. <code>scale</code> <code>str</code> Hydropathy scale identifier (e.g., <code>\"kd\"</code> for Kyte-Doolittle). <p>Returns</p> <p><code>dict</code> with canonical protein metrics: <code>sequence</code>, <code>length</code>, <code>molecular_weight</code>, <code>aromaticity</code>, <code>instability_index</code>, <code>gravy</code>, <code>charge_at_pH7</code>, plus <code>hydropathy_profile</code> entries (<code>start</code>, <code>end</code>, <code>score</code>). Raises <code>ImportError</code> if Biopython is unavailable so that workflows can fail fast with a clear dependency message.</p>"},{"location":"reference/api/#run_workflowconfig_path-output_dir-namenone","title":"<code>run_workflow(config_path, *, output_dir, name=None)</code>","text":"<p>Execute a YAML workflow definition (the same format consumed by <code>helix workflows run</code>) from Python. The helper wraps <code>helix_workflows.run_workflow_config</code>, returning the list of materialized artifacts. <code>name</code> can restrict execution to a single workflow from a manifest, mirroring the CLI <code>--name</code> flag.</p>"},{"location":"reference/api/#usage-patterns","title":"Usage patterns","text":"<pre><code>from pathlib import Path\nfrom helix import api as hx\n\nreport = hx.triage_report(sequence=\"AUGGCCUUUUAA\", k=3)\ngc_bins = hx.dna_summary(input_path=Path(\"samples/ecoli.fna\"), window=500, step=50)\nrna = hx.fold_rna(\"GGGAAACCC\", min_loop_length=0)\npeptides = hx.spectrum_leaderboard(\n    experimental_spectrum=[0, 113, 128, 227, 242, 355, 370, 484],\n    leaderboard_size=10,\n)\n</code></pre> <p>Each function returns plain JSON-serializable structures, making it trivial to call <code>json.dumps(...)</code>, ship results to <code>helix viz ...</code>, or interoperate with scientific Python stacks. Exceptions surface early and with actionable messages\u2014ideal for research-grade reproducibility and provenance.</p> <p>Need performance baselines? Run <code>python -m benchmarks.api_benchmarks --repeat 5 --limit 0 --sort mean --out bench/api.json</code> from the repo root to capture timing data for every helper (or focus on specific functions via <code>--scenario</code>). Set <code>HELIX_BENCH_DNA_FASTA</code> / <code>HELIX_BENCH_PROTEIN_FASTA</code> to swap in larger genomes or proteomes once available, and use <code>--limit 10000</code> to mimic CI\u2019s quicker sampling. Each run emits a schema-tagged payload (<code>bench_result</code> v1.0) that logs git SHA, BLAS vendor, CPU/threads, RNG seed, and per-case RSS stats so notebooks + CI can do apples-to-apples comparisons. Compare two runs via <code>scripts/bench_check.py baseline.json current.json --threshold 5</code> to flag &gt;5% slowdowns automatically, and browse the rolling history at <code>docs/benchmarks.md</code>.</p>"},{"location":"visualization/alignment-ribbon/","title":"Alignment Ribbon","text":"<pre><code>helix viz alignment-ribbon --input map.json --save ribbon.png\n</code></pre> <p>Inputs: JSON from <code>helix seed map</code>. Output: diagonal ribbon highlighting matches/indels, plus <code>ribbon.viz.json</code> + <code>ribbon.provenance.json</code> for reproducibility.</p>"},{"location":"visualization/distance-heatmap/","title":"Distance Heatmap","text":"<pre><code>helix viz distance-heatmap --input distances.json --save distances.png\n</code></pre> <p>Plots MinHash/HLL distance matrices with consistent metadata (labels, min/max/mean). Ideal for quick clustering demos.</p>"},{"location":"visualization/minimizer-density/","title":"Minimizer Density","text":"<pre><code>helix viz minimizers --input minimizers.json --bins 200 --save mins.png\n</code></pre> <p>Shows seed density along a sequence. Schema-aware payloads let you mix integers, tuples, or dicts, and the viz-spec tracks binning statistics for regression tests.</p>"},{"location":"visualization/motif-logo/","title":"Motif Logo","text":"<pre><code>helix viz motif-logo --input motif.json --save motif.png\n</code></pre> <p>Renders PWM columns as information logos (bits). Accepts uniform or custom backgrounds; emits spec/provenance files alongside the image.</p>"},{"location":"visualization/rna-dotplot/","title":"RNA Dot-Plot","text":"<pre><code>helix viz rna-dotplot --input ensemble.json --save dotplot.png\n</code></pre> <p>Visualizes McCaskill pairing posteriors (<code>P[i,j]</code>). Upper triangle heatmap + <code>dotplot.viz.json</code> + provenance trailer guarantee notebook-to-figure parity.</p>"}]}